---
title: A Scala Compiler Plugin for Avro Records
layout: post
---
<div class="posterous_bookmarklet_entry">
<blockquote>
<div>
  <a rel="nofollow">Background</a> 
<a rel="nofollow"><p>We are attempting to build a scala compiler plugin to auto-generate avro classes based on some simple definitions. This plugin is for the Scala 2.8 compiler, and for the Avro 1.3.0 runtime. </p></a> <a rel="nofollow">Usage</a> 
<a rel="nofollow"><p>Let us define a simple record class. Normally in Avro, you would write a JSON file which looks like this: </p>
<div class="CodeRay">
  <div class="code"><pre>{"namespace" : "localhost.test","protocol"  : "Test","types" : [   { "name" : "Item", "type" : "record", "fields" : [      { "name" : "name", "type" : "string" },      { "name" : "cost", "type" : "double" }   ]},   { "name" : "ItemList", "type" : "record", "fields" : [      { "name" : "items" , "type" : { "type" : "array", "items" : "Item" } }   ]}]}</pre></div>
</div></p><p><p>In which case, the Avro compiler will generate Item.java and ItemList.java for you to use in your application (which you can then use in your Scala application). </p>
<p>With our plugin, you can instead write Scala case classes which accomplish the same task, but look a lot cleaner: </p>
<div class="CodeRay">
  <div class="code"><pre>package localhost.testimport com.googlecode.avro.annotation.AvroRecord@AvroRecordcase class Item (var name: String, var cost: Double)@AvroRecordcase class ItemList (var items: List[Item])</pre></div>
</div></p><p><p>That's all you need to do! Our compiler plugin will automatically generate the necessary methods that make your case classes Avro serializable. All you need to do is to run scalac with the plugin: </p>
<div class="CodeRay">
  <div class="code"><pre>$ scalac -classpath target/avro-scala-compiler-plugin-1.0-SNAPSHOT.jar -Xpluginsdir target -d target/classes test.scala</pre></div>
</div></p><p><p>Now you can use the classes as such: </p>
<div class="CodeRay">
  <div class="code"><pre>import localhost.test._import java.io.ByteArrayOutputStreamimport java.nio.ByteBufferimport org.apache.avro.specific._import org.apache.avro.io._import scala.reflect.Manifestdef toByteArray[ T </pre></div>
</div></p><p><p>Which produces the following output (assuming that the generated classes are in your classpath): </p>
<div class="CodeRay">
  <div class="code"><pre>Original itemList: {"items": [{"name": "Pen", "cost": 0.5}, {"name": "Chair", "cost": 15.99}]}New itemList: {"items": [{"name": "Pen", "cost": 0.5}, {"name": "Chair", "cost": 15.99}]}</pre></div>
</div></p><p><p>We can also handle unions in a typesafe manner: </p>
<div class="CodeRay">
  <div class="code"><pre>package localhost.testunionimport com.googlecode.avro.annotation.{AvroRecord, AvroUnion}@AvroUnionsealed trait Car @AvroRecordcase class Honda(var model: String) extends Car @AvroRecordcase class Toyota(var model: String) extends Car @AvroRecordcase class Dealer(var cars: List[Car])</pre></div>
</div></p><p><p>Which we can then use as such: </p>
<div class="CodeRay">
  <div class="code"><pre>import localhost.testunion._val dealer = Dealer ( List ( Honda( "Pilot" ), Toyota( "Camry" ) ) )println("Dealer: " + dealer)</pre></div>
</div></p><p><p>Which will output: </p>
<div class="CodeRay">
  <div class="code"><pre>Dealer: {"cars": [{"model": "Pilot"}, {"model": "Camry"}]}</pre></div>
</div>
</a> <a rel="nofollow">Performance</a> 
<a rel="nofollow"><p>I ran some very preliminary performance tests comparing Avro serialization when using the supplied Java compiler, Avro serialization with this plugin, and native Java serialization. Here are the results: <img src="http://avro-scala-compiler-plugin.googlecode.com/files/graph2.png" height="375" width="500" /></p></a><p><a rel="nofollow">See </a><a href="http://code.google.com/p/avro-scala-compiler-plugin/source/browse/trunk/script_test_classes.scala" rel="nofollow">http://code.google.com/p/avro-scala-compiler-plugin/source/browse/trunk/script_test_classes.scala</a> for the test code. The record of interest was </p>
<div class="CodeRay">
  <div class="code"><pre>case class Record(var x: Int, var y: String, var z: Boolean)</pre></div>
</div></p><p><p>See <a href="http://code.google.com/p/avro-scala-compiler-plugin/source/browse/trunk/test_classes.scala" rel="nofollow">http://code.google.com/p/avro-scala-compiler-plugin/source/browse/trunk/test_classes.scala</a> for the actual code of the records.  </p>
<p><strong>Stock</strong> indicates a SpecificRecord generated by the supplied Avro compiler.  </p>
<p><strong>Plugin</strong> indicates a SpecificRecord generated by this compiler plugin.  </p>
<p><strong>Java</strong> indicates a Scala case class which implements java.io.Serializable. </p>
<p>In addition to performance, I measured the length of the byte string generated by each of these methods (for the record given above). The results were: </p>
<ul>
<li>
<strong>Stock</strong> - 18 bytes </li>
<li>
<strong>Plugin</strong> - 18 bytes  </li>
<li>
<strong>Java</strong> - 100 bytes </li>
</ul>
 <a rel="nofollow">Known Limitations</a> 
<a rel="nofollow"><ul>
<li>This only works for Scala case class classes at the top level. </li>
<li>Several Avro features are punted on. These include enumerations, fixed record fields, and maps.  </li>
<li>Right now, you have to add the companion object class manually. I plan to fix this soon. </li>
<li>
null fields are not properly handled right now. </li>
</ul></a> <a rel="nofollow">TODO List</a> 
<a rel="nofollow"><ul>
<li>
<span>Move the schema to a Scala object, so that schemas do not have to be reparsed every new instance is generated</span> </li>
<li>To implement the above fix, I introduced a hack where you have to add the companion object class manually. See <strong>Known Limitations</strong>.  </li>
<li>Handle maps (which Avro supports). </li>
<li>Handle null fields. </li>
<li>
<strong>Do the right thing</strong> when it comes to byte arrays and strings. Right now the user is forced to use an Array[Byte] for a byte array, and a String for a string. However, since these are represented in Avro as java.nio.ByteBuffer and org.apache.avro.util.Utf8 internally, the user should be able to specify said types and get the indended meaning (right now this is an error).  </li>
<li>Use the Scala Option[T] class to handle fields which can be null.   </li>
<li>Consider using the Scala Either[A,B] class as a shorthand for a simple two part union. </li>
<li>Be more robust with error handling (rather than throwing random exceptions). </li>
<li>Find a way to make this work in the Scala REPL.  </li>
<li>Recover the lost performance when using the plugin versus the Avro Java compiler.  </li>
<li>Find a way to integrate this into a build process better (right now you have to set the correct classpaths and stuff yourself). </li>
</ul></a>
</div></p><p></blockquote>
<div class="posterous_quote_citation">
<a rel="nofollow">via </a><a href="http://code.google.com/p/avro-scala-compiler-plugin/" rel="nofollow">code.google.com</a>
</div>
    
</div>
