---
title: A comparison of efficient data structures
layout: post
---
<div class="posterous_bookmarklet_entry">
<blockquote class="posterous_long_quote">
<p>Since my <a href="http://www.mail-archive.com/zeromq-dev@lists.zeromq.org/msg01133.html" rel="nofollow">discussion thread</a> on the efficiency of the in-memory data structure of <a href="http://zeromq.org" rel="nofollow">ZeroMQ</a> with Martin Sustrik, I have been reading up a bit by bit on efficient data structures, primarily from the perspective of memory utilization. Data structures that provide constant lookup time with minimal memory utilization can give a significant performance boost since access to CPU cache is considerably faster than access to RAM. This post is a compendium of a few data structures I came across and salient aspects about them</p>
<p><strong>Judy arrays</strong> – <a href="http://judy.sourceforge.net/doc/10minutes.htm" rel="nofollow">http://judy.sourceforge.net/doc/10minutes.htm<br /></a>Excerpt: A Judy tree is generally faster than and uses less memory than contemporary forms of trees such as binary (AVL) trees, b-trees, and skip-lists. When used in the “Judy Scalable Hashing” configuration, Judy is generally faster then a hashing method at all populations. A (CPU) <em>cache-line fill</em> is additional time required to do a read reference from RAM when a word is not found in cache. In today’s computers the time for a cache-line fill is in the range of 50..2000 machine instructions. Therefore a cache-line fill should be avoided when fewer than 50 instructions can do the same job. Judy rarely compromises speed/space performance for simplicity (Judy will never be called simple except at the API). Judy is designed to avoid cache-line fills wherever possible. The Achilles heel of a simple digital tree is very poor memory utilization, especially when the N in N-ary (the degree or fanout of each branch) increases. The Judy tree design was able to solve this problem. In fact a Judy tree is more memory-efficient than almost any other competitive structure (including a simple linked list).</p>
<p><strong>HAT-trie – a cache concious trie</strong> – <a href="http://portal.acm.org/citation.cfm?id=1273761" rel="nofollow">http://portal.acm.org/citation.cfm?id=1273761<br /></a>Excerpt: Tries are the fastest tree-based data structures for managing strings in-memory, but are space-intensive. The burst-trie is almost as fast but reduces space by collapsing trie-chains into buckets. This is not however, a cache-conscious approach and can lead to poor performance on current processors. In this paper, we introduce the HAT-trie, a cache-conscious trie-based data structure that is formed by carefully combining existing components. We evaluate performance using several real-world datasets and against other high-performance data structures. We show strong improvements in both time and space; in most cases approaching that of the cache-conscious hash table. Our HAT-trie is shown to be the most efficient trie-based data structure for managing variable-length strings in-memory while maintaining sort order.</p>
<p><strong>Burst Trie</strong> – <a href="http://goanna.cs.rmit.edu.au/~jz/fulltext/acmtois02.pdf" rel="nofollow">http://goanna.cs.rmit.edu.au/~jz/fulltext/acmtois02.pdf<br /></a>Excerpt: Many applications depend on efficient management of large sets of distinct strings in memory. We propose a new data structure, the burst trie, that has signicant advantages over existing options for such applications: it requires no more memory than a binary tree; it is as fast as a trie; and, while not as fast as a hash table, a burst trie maintains the strings in sorted or near-sorted order. These experiments show that the burst trie is particularly effective for the skewed frequency distributions common in text collections, and dramatically outperforms all other data structures for the task of managing strings while maintaining sort order.</p>
<p><strong>Radix trie (aka Patricia trie)</strong> – <a href="http://en.wikipedia.org/wiki/Radix_tree" rel="nofollow">http://en.wikipedia.org/wiki/Radix_tree<br /></a>Excerpt: The radix tree is easiest to understand as a space-optimized trie where each node with only one child is merged with its child. Unlike balanced trees, radix trees permit lookup, insertion, and deletion in O(k) time rather than O(log n)</p>
<p><strong>Ternary Search Trees - <span><a href="http://en.wikipedia.org/wiki/Ternary_search_tree" rel="nofollow">http://en.wikipedia.org/wiki/Ternary_search_tree<br /></a>Excerpt: A trie is optimized for speed at the expense of size. The ternary search tree replaces each node of the trie with a modified binary search tree. For sparse tries, this binary tree will be smaller than a trie node. Each binary tree implements a single-character lookup. It has the typical left and right children which are checked if the lookup character is greater or less than the node’s character, respectively. A third child is used if the lookup character is found on that particular node. Unlike the other children, it links to the root of the binary search tree for the next character in the string</span></strong></p>
<p><strong><span>Next steps: to trie <img class="wp-smiley" src="http://bhavin.directi.com/wp-includes/images/smilies/icon_wink.gif" height="18" width="18" />  and setup benchmarks for some of these on a practical application</span></strong></p></p><p></blockquote></p><p><div class="posterous_quote_citation">via <a href="http://bhavin.directi.com/to-trie-or-not-to-trie-a-comparison-of-efficient-data-structures/" rel="nofollow">bhavin.directi.com</a>
</div>
    
</div>
